<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>[컴퓨터 그래픽스] 중간고사 대비</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap"
      rel="stylesheet"
    />
  </head>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "Noto Sans KR", sans-serif;
    }

    html,
    body {
      display: flex;
      justify-content: center;
      min-width: 100vw;
      min-height: 100vh;
      background-color: #30313e;
    }

    #main {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 50px 0;
      width: 550px;
      min-height: 100vh;
    }

    .filter {
      padding: 16px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      border-radius: 16px;
      background-color: #1d1d22;
      box-shadow: 0 4px 12px 0 rgba(0, 0, 0, 0.16);
      gap: 12px;

      & > .filter-item {
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 1 1 auto;
        height: 40px;
        border-radius: 6px;
        border: solid 1px #134fcf;
        background-color: white;
        font-size: 14px;
        color: #134fcf;
        cursor: pointer;
        transition: 0.1s;

        &.selected {
          background-color: #134fcf;
          font-weight: 500;
          color: white;
        }
      }
    }

    .box {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      min-height: 500px;

      & > textarea {
        padding: 12px 16px;
        height: 120px;
        border: solid 2px #1d1d22;
        background-color: rgba(29, 29, 34, 0.4);
        font-size: 14px;
        color: white;
        transition: 0.1s;
        resize: none;
        outline: none;

        &:focus {
          border: solid 2px #134fcf;
        }
      }

      & > .question {
        padding: 16px 24px;
        width: 100%;
        border-radius: 12px;
        background-color: white;
        font-size: 14px;
        font-weight: 500;
      }

      & > .answers {
        padding: 16px 48px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        border-radius: 12px;
        border: solid 2px #1d1d22;
        background-color: rgba(29, 29, 34, 0.4);
        font-size: 14px;
        font-weight: lighter;
        color: white;

        & > li {
          word-break: keep-all;

          &:first-of-type {
            margin-left: -24px;
            padding: 4px 12px;
            align-self: flex-start;
            list-style: none;
            border-radius: 6px;
            background-color: #1d1d22;
            font-size: 12px;
            font-weight: 500;
          }
        }
      }
    }

    button {
      align-self: flex-end;
      width: 100%;
      height: 45px;
      border-radius: 8px;
      border: none;
      background-color: #1d1d22;
      box-shadow: 0 4px 12px 0 rgba(0, 0, 0, 0.2);
      font-weight: 500;
      color: white;
      cursor: pointer;
    }

    @media (max-width: 480px) {
      #main {
        width: 340px;
      }
    }
  </style>
  <body>
    <div id="main">
      <div class="box">
        <div class="question">
          <strong>[문제]</strong> 문제를 먼저 생성해주세요!
        </div>

        <textarea placeholder="여기에 답을 작성하고 확인해보세요!"></textarea>

        <ul class="answers" style="display: none"></ul>
      </div>
    </div>

    <script>
      const chapter1 = [
        {
          chapter: "1장",
          question: "디지털 영상 처리",
          answer: [
            "디지털 신호 처리의 하위 분야로 컴퓨터 알고리즘을 사용하여 디지털 영상에 대한 일련의 정보 처리를 수행하는 것",
            "입력 자료에 더욱 광범위한 알고리즘을 적용할 수 있게 하고, 처리 도중 발생하는 잡음과 신호 왜곡과 같은 문제들을 방지할 수 있어서 아날로그 영상 처리에 비해 많은 장점이 있음",
          ],
        },
        {
          chapter: "1장",
          question: "디지털 영상 처리 시스템",
          answer: [
            "아날로그 영상을 디지털 데이터로 변환, 가공, 재생하는 전체 시스템",
          ],
        },
        {
          chapter: "1장",
          question: "아날로그 - 디지털 변환기",
          answer: [
            "샘플링(Sampling)과 양자화(Quantization)라는 중요한 두 가지 작업이 필요함",
          ],
        },
        {
          chapter: "1장",
          question: "샘플링(Sampling)",
          answer: [
            "연속적인 아날로그 신호로부터 일정한 간격의 주기로 신호의 강도를 수집하는 것",
            "주기가 짧을수록 보다 선명한 영상을 얻을 수 있고 주기가 클수록 영상의 선명도가 떨어짐",
          ],
        },
        {
          chapter: "1장",
          question: "양자화(Quantization)",
          answer: [
            "각 샘플링 단계에서 얻어진 신호값을 일정한 범위의 디지털 값으로 매핑시키는 과정",
          ],
        },
        {
          chapter: "1장",
          question: "영상 기본 단위: 픽셀(Pixel)",
          answer: [
            "텔레비전이나 사진 전송에서, 화면을 전기적으로 나눈 최소의 단위 면적",
          ],
        },
        {
          chapter: "1장",
          question: "영상의 해상도(크기)",
          answer: [
            "화면에서 표현되는 영상의 픽셀 수를 나타내는 기준으로 영상을 표현하는데 '가로 x 세로'로 몇 개의 픽셀이 사용되었는가를 나타냄",
          ],
        },
        {
          chapter: "1장",
          question: "영상의 유형",
          answer: ["Gray Scale 영상과 True Color 영상으로 나뉨"],
        },
        {
          chapter: "1장",
          question: "디지털 영상",
          answer: [
            "영상 획득 과정에서 카메라 렌즈나 장비 등의 문제로 인해 잡음이나 회전, 왜곡 등이 발생할 수 있음",
            "이러한 영상의 문제들을 다양한 영상 처리 기법들을 이용하여 개선할 수 있음",
          ],
        },
        {
          chapter: "1장",
          question: "영상의 화질 개선",
          answer: [
            "영상에 포함된 잡음 제거, 영상의 밝기 성질 개선, 영상의 명암 대비(contrast) 개선, 영상의 선명도 향상 등의 방법들을 포함",
          ],
        },
        {
          chapter: "1장",
          question: "영상의 기하학적 변환",
          answer: [
            "영상을 회전, 이동, 크기를 변환시키는 기법을 의미",
            "영상 획득 시에 발생되는 여러 가지 기하학적 오류을 개선하거나 영상을 효과적으로 분석하기 위해 주로 사용됨",
          ],
        },
        {
          chapter: "1장",
          question: "영상 변환",
          answer: [
            "공간 영역(Spatial Domain) 상에 존재하는 픽셀을 주파수 영역(Frequency Domain)으로 변형하는 방법",
            "이를 통해 영상의 명암값의 변화 정도를 나타내는 공간 주파수 정보를 쉽게 파악할 수 있음",
          ],
        },
        {
          chapter: "1장",
          question: "영상 분석",
          answer: [
            "영상으로부터 수치화된 특징을 추출하여 영상을 분류 또는 판독하는 과정",
          ],
        },
        {
          chapter: "1장",
          question: "영상 처리 응용 분야",
          answer: [
            "내용 기반 영상 검색(Content-based Image Retrieval), 인공위성 분석, 화재 감지 등이 있음",
          ],
        },
        {
          chapter: "1장",
          question: "영상 처리 프로그램을 하기 위해",
          answer: [
            "C 또는 C++로 모든 코드를 작성하는 것이 기본이지만, 한편으로는 실시간 컴퓨터 비전 처리를 목적으로 만들어진 OpenCV(Open source Computer Vision) 라이브러리를 많이 사용하기도 함",
          ],
        },
        {
          chapter: "1장",
          question: "구글 코랩",
          answer: [
            "별다른 설치 없이 웹 브라우저만을 이용해 주피터 노트북으로 작업할 수 있고 다른 사용자들과 공유가 쉽다는 것이 장점",
          ],
        },
        {
          chapter: "1장",
          question: "구글 코랩 환경",
          answer: [
            "데이터 분석에 자주 사용되는 패키지들이 이미 설치되어 있음",
            "명령창에 패키지들을 import 시켜보고 에러가 없다면 문제없이 코랩에서 해당 패키지들을 지원하고 있다는 것을 의미",
          ],
        },
      ];
      const chapter2 = [
        {
          chapter: "2장",
          question: "디지털 영상 표현을 위한 색상 표현",
          answer: [
            "RGB의 3가지 색상의 조합으로 표현",
            "컴퓨터에서 영상을 표현하기 위한 색상 모델은 RGB, CMY, HSV, YIQ, YCrCb가 있음",
          ],
        },
        {
          chapter: "2장",
          question: "RGB 색상 모델",
          answer: ["빛의 3원색인 Red, Green, Blue의 가산 조합으로 만들어짐"],
        },
        {
          chapter: "2장",
          question: "HSV 색상 모델",
          answer: [
            "RGB 색상 모델이 인간의 색상 정보 체계와는 다르다는 문제점을 해결하고, 인간이 인식하는 색상과 흡사한 색상 모델을 만들기 위해 고안된 색상 모델",
            "Hue(색상), Saturation(채도), Value(명도)를 의미",
          ],
        },
        {
          chapter: "2장",
          question: "YIQ 색상 모델",
          answer: [
            "NTSC(National Television Standards Committee) TV 표준에서 사용하는 방식",
            "Y(휘도, Iuminance), I(주황-청색, Orange-Blue), Q(자주-녹색, Purple-Green)를 의미",
          ],
        },
        {
          chapter: "2장",
          question: "RAW 영상",
          answer: [
            "영상 구성(Configuration)에 대한 헤더 정보를 포함하지 않고 영상의 픽셀값만을 가지고 있는 파일",
          ],
        },
        {
          chapter: "2장",
          question: "BMP 영상(Bitmap)",
          answer: [
            "MS에서 윈도우즈 기반 운영체제에서 사용할 목적으로 만들어진 영상 저장 방식",
          ],
        },
        {
          chapter: "2장",
          question: "JPEG (Joint Photographic Experts Group)",
          answer: ["정지 영상을 위해서 만들어진 손실 압축 방법 표준"],
        },
        {
          chapter: "2장",
          question: "BMP",
          answer: [
            "장치 의존 비트맵(DDB: Device Dependent Bitmap)과 장치 독립 비트맵(DIB: Device Independent Bitmap)으로 나뉨",
          ],
        },
        {
          chapter: "2장",
          question: "장치 의존 비트맵(DDB: Device Dependent Bitmap)",
          answer: [
            "출력 장치에 나타나는 영상이 모니터의 화면에 설정된 값에 의해 출력되는 방식",
          ],
        },
        {
          chapter: "2장",
          question: "장치 독립 비트맵(DIB: Device Independent Bitmap)",
          answer: [
            "출력 장치의 설정이 달라지더라도 자신의 비트맵 값이 그대로 출력되는 방식",
          ],
        },
        {
          chapter: "2장",
          question: "RGB 영상을 JPEG 영상으로 변환되는 순서",
          answer: [
            "RGB 색공간에서 YCrCb 색공간으로 전환",
            "색상 체널에 대한 다운 샘플링",
            "이산코사인변환(DCT) 변환",
            "양자화",
            "zig-zag 스캐닝",
            "인코딩을 이용한 부호화",
          ],
        },
        {
          chapter: "2장",
          question: "Numpy(Numerical Python)",
          answer: [
            "C언어로 구현된 파이썬 라이브러리로 고성능 수치 계산을 위해 만들어짐",
            "array 단위로 벡터 및 행렬 연산에 있어서 매우 편리한 기능을 제공하며 데이터 분석에 사용되는 라이브러리인 pandas와 matplotlib의 기반으로 사용됨",
          ],
        },
      ];
      const chapter3 = [
        {
          chapter: "3장",
          question: "픽셀",
          answer: [
            "영상 처리에서 가장 기본적인 단위로서 입력 영상의 한 픽셀을 매핑 함수에 적용하여 출력 영상의 한 픽셀을 얻을 수 있음",
          ],
        },
        {
          chapter: "3장",
          question: "픽셀 더하기 연산",
          answer: [
            "동일한 크기의 두 영상으로부터 동일한 좌표의 각 픽셀들을 더하여 결과 영상에 입력하는 방식",
          ],
        },
        {
          chapter: "3장",
          question: "Saturation",
          answer: [
            "픽셀값이 설정된 최대값을 초과할 경우 초과된 값을 설정된 최대값으로 교체",
          ],
        },
        {
          chapter: "3장",
          question: "Wrapping",
          answer: [
            "픽셀값이 설정된 최대값을 초과할 경우 초과된 값에서 '최대값 + 1'을 뺀 값으로 픽셀 값을 교체",
          ],
        },
        {
          chapter: "3장",
          question: "최대-최소 정규화",
          answer: [
            "연산이 끝난 영상에서 최대값과 최소값을 찾고 수식을 이용하여 값을 원하는 범위 사이로 정규화 함",
          ],
        },
        {
          chapter: "3장",
          question: "픽셀 빼기 연산",
          answer: [
            "동일한 크기의 두 영상으로부터 동일한 좌표의 각 픽셀들을 뺀 값을 결과 영상에 입력하는 방법",
            "계산 중 결과 값이 음수가 될 수 있으므로 뺄셈 연산에 절대값을 취하여 입력할 수도 있음",
          ],
        },
        {
          chapter: "3장",
          question: "픽셀 곱하기 연산",
          answer: [
            "동일한 크기의 두 영상으로부터 동일한 좌표의 각 픽셀들의 곱한 값을 결과 영상에 입력하는 방법",
            "픽셀 곱셈에서도 Overflow가 발생할 수 있는데 이 경우 픽셀 덧셈에서의 방법과 마찬가지로 Saturation, Wrapping, 최대-최소 정규화 방법들을 사용할 수 있음",
          ],
        },
        {
          chapter: "3장",
          question: "픽셀 나누기 연산",
          answer: [
            "동일한 크기의 두 영상으로부터 동일한 좌표의 각 픽셀들을 나눈 값을 결과 영상에 입력하는 방법",
            "연산된 값이 부동소수점 값이 될 수 있는데 출력 영상에서는 정수형으로 입력되어야 하므로 결과값에서 소수점 이하를 버림 혹은 반올림을 취함",
          ],
        },
        {
          chapter: "3장",
          question: "픽셀 결합",
          answer: [
            "두 개의 동일한 크기의 입력 영상을 결합하는 방법으로 다른 산술 연산 방법과 마찬가지로 대응되는 두 영상의 픽셀들을 선형 결합 방식에 의해 결합하여 출력 영상을 재생",
          ],
        },
        {
          chapter: "3장",
          question: "픽셀 AND 비트 연산",
          answer: [
            "두 개의 이진 영상이나 컬러 영상을 입력으로 받고 두 개의 입력 영상에 대응되는 픽셀 사이에 AND 비트 연산을 수행한 결과를 출력 영상의 픽셀 값으로 설정",
          ],
        },
        {
          chapter: "3장",
          question: "픽셀 OR 비트 연산",
          answer: [
            "두 영상에 대응되는 픽셀 값의 OR 비트 연산 값을 출력 영상의 픽셀값으로 설정",
          ],
        },
        {
          chapter: "3장",
          question: "픽셀 반전 연산",
          answer: [
            "이진 영상의 경우 검은색 픽셀은 흰색으로 흰색 픽셀은 검은색으로 매핑하고, 컬러 영상의 경우 각 픽셀값의 보수로 매핑되는 연산을 의미",
          ],
        },
      ];
      const chapter4 = [
        {
          chapter: "4장",
          question: "히스토그램(Histogram)",
          answer: [
            "영상 안에 포함된 각각 다른 밝기 값을 갖는 픽셀들의 수(분포)를 보여주는 그래프",
          ],
        },
        {
          chapter: "4장",
          question: "임계값 적용하기",
          answer: [
            "전경 영역과 배경 영역의 밝기 차이나 색상 차이를 이용하여 영상의 배경으로부터 전경 영역들을 분리할 수 있는 가장 기본적인 방법",
          ],
        },
        {
          chapter: "4장",
          question: "임계값",
          answer: [
            "인위적으로 프로그래머에 의해 결정될 수도 있지만, 영상으로부터 히스토그램을 생성하여 결정할 수 있음",
          ],
        },
        {
          chapter: "4장",
          question: "히스토그램이 두 개의 봉우리로 확연히 구분되는 경우",
          answer: [
            "한 개의 임계값만으로도 영상 내에 포함된 영역들을 효과적으로 분리할 수 있음",
          ],
        },
        {
          chapter: "4장",
          question: "히스토그램이 두 개 이상의 봉우리로 확연히 구분되는 경우",
          answer: [
            "한 개의 임게값으로는 구분이 되지 않기 때문에 임계값을 추가해주어야 함",
          ],
        },
        {
          chapter: "4장",
          question: "히스토그램의 봉우리가 모호한 경우",
          answer: ["임계값을 이용한 영역 분리는 잘못된 결과를 보여줌"],
        },
        {
          chapter: "4장",
          question: "전역 임계값 적용 방법",
          answer: [
            "두 개의 그룹으로 분할하고 각 그룹마다 평균값을 계산하여 이 값들을 임게값 계산에 적용하는 방법을 사용",
            "이렇게 구해진 임계값을 모든 픽셀에 대해 적용하는 방식으로 영상이 전경과 배경으로 확연히 구분될 경우 매우 뛰어난 성능을 발휘",
          ],
        },
        {
          chapter: "4장",
          question: "전역 임계값 알고리즘",
          answer: [
            "종료 조건에 해당하는 TO에 따라 영상 분할 속도가 달라질 수 있음",
          ],
        },
        {
          chapter: "4장",
          question: "TO 값이 작을 경우",
          answer: [
            "최적의 임계값을 추정할 수 있지만 많은 연산이 필요하므로 실행 속도가 느려질 수 있음",
          ],
        },
        {
          chapter: "4장",
          question: "적응적 임계값 적용 방법",
          answer: [
            "전역 임계값 적용 방법의 단점인 영상 안에 조명이 일정하지 않거나 다양한 색상을 가지는 전경 물체가 있을 경우 하나의 임계값만으로 전경과 배경이 구분되지 않는 문제를 보완하는 방법",
            "영상을 N x N 블록으로 일정하게 분할하고 각 분할된 블록마다 제각기 다른 임계값을 결정하는 방법",
          ],
        },
        {
          chapter: "4장",
          question:
            "작은 블록은 대략적으로 균등한 조명을 가질 가능성이 크기 때문에 임계값 적용에 보다 적합",
          answer: [
            "이 방법에서의 문제는 블록의 크기가 너무 작을 경우 영상이 너무 세분화되어 잡영상이 많아지고, 너무 큰 경우 블록 내의 픽셀들은 일정한 조명을 갖는다는 적응적 임계값 적용 방법의 기본 가정을 위반하므로 전역적 임계값 방법과 유사한 결과를 나타냄",
            "영상의 특성과 크기에 따라 블록의 크기를 가변적으로 결정해주어야 함",
          ],
        },
        {
          chapter: "4장",
          question: "히스토그램 스트레칭 방법",
          answer: [
            "영상의 밝기값 범위를 확장 똔느 축소 시킴으로써 영상의 대비를 향상시키는 방법",
            "영상 픽셀들에 대해 선형 확장 함수(Linear Scaling Function)을 적용하여 구현할 수 있음",
            "변환 결과는 히스토그램의 분포는 원래 영상의 히스토그램 분포에서 같은 비율로 확정된 분포를 갖게 됨",
            "영상에 포함된 픽셀의 최고 밝기값과 최소 밝기값에 민감하기 때문에 상하위 절단법과 같은 방법을 사용하여 최고 밝기값과 최소 밝기값을 구함",
          ],
        },
        {
          chapter: "4장",
          question: "히스토그램 평활화",
          answer: [
            "비선형적인 함수를 이용하여 영상으로 하여금 정규 분포 형태의 히스토그램을 갖도록하여 화질을 개선하는 방법",
            "변환 결과는 히스토그램의 분포는 균일 분포(Uniform Distribution) 형태가 됨",
          ],
        },
      ];
      const chapter5 = [
        {
          chapter: "5장",
          question:
            "일반적인 방법 설명",
          answer: ["대부분의 공간적 필터링 기법들은 각각의 목적에 따라 적절한 커널을 정의하고 원본 영상과 컨벌루션 연산을 수행하는 것이 일반적이다."],
        },
        {
          chapter: "5장",
          question: "컨벌루션 연산",
          answer: [
            "입력 영상의 픽셀 밝기값을 커널의 동일한 위치에 해당하는 픽셀값과 곱하고 모든 값들을 더한 값으로 대체하는 방법",
          ],
        },
        {
          chapter: "5장",
          question: "평균 필터링",
          answer: [
            "입력 영상의 픽셀 밝기값을 주변 픽셀들의 밝기값의 평균으로 대체하여 영상을 스무딩(smoothing) 시키는 방법으로 잡음을 줄이는 필터링 기법",
            "간단한 컨벌루션 연산으로 가우시안 잡음을 제거할 수 있으나, 선형 필터로 보간(interpolation)효과에 의해 경계선과 같은 에지의 세밀함을 감소",
            "잡음 픽셀의 밝기값이 주변 픽셀의 밝기값 결정을 위한 평균 계산에 큰 영향을 주기 때문에 전체적으로 잡음이 제대로 제거되지 않아 Salt & Pepper 잡음을 효과적으로 제거하지 못함",
          ],
        },
        {
          chapter: "5장",
          question: "중간값 필터링",
          answer: [
            "입력 영상의 현재 픽셀을 중심으로 커널을 씌우고, 커널 안에 포함된 주변 픽셀들을 밝기값 기준으로 정렬하여 중간에 위치한 값으로 대체하는 기법",
            "하나의 픽셀 단위로 튀는 Salt & Pepper 잡음 제거에 가장 효과적이나 정렬을 위한 추가적인 연산이 필요하며, 비선형 필터로 기존의 주변 픽셀 밝기값을 그대로 이용하여 평균 필터에 비해 영상의 세밀함을 유지할 수 있음",
          ],
        },
        {
          chapter: "5장",
          question:
            "스무딩의 정도 심해짐 설명",
          answer: ["대부분의 컨벌루션 커널과 공통적으로 가우시안 커널도 크기가 커짐에 따라 스무딩의 정도가 심해지지만, 추가적으로 커널의 분산이 커질수록 스무딩 정도가 심해짐"],
        },
        {
          chapter: "5장",
          question: "가우시안 필터링",
          answer: [
            "2차 가우시안 함수에 따른 가우시안 분포를 근사 시킨 커널(가우시안 커널)을 이용하며, 커널의 크기는 분산에 의해 결정됨.",
            "평균 필터링에 비해 세밀함을 유지하면서 잡음을 제거할 수 있음",
            "가우시안 분포를 보이는 잡음에 대해서는 탁월한 제거 효과를 보이지만 Salt & Pepper 잡음과 같은 임펄스 잡음에는 제거 효과가 떨어짐"
          ],
        },
        {
          chapter: "5장",
          question: "보존 스무딩",
          answer: [
            "중간값 필터링과 같은 비선형 필터로 주변 픽셀과 비교하여 너무 높거나 낮은 밝기값을 가지는 경우 가장 가까운 밝기값으로 대체함.",
            "중간값 필터링과 같이 영상의 세밀함을 유지하며 잡음을 제거할 수 있음",
          ],
        },
        {
          chapter: "5장",
          question: "언샤프 필터링",
          answer: [
            "영상의 에지와 같은 고주파 성분을 강조하는 필터로 선명하지 않은 영상의 선명도를 향상시키기 위하여 주로 이용됨",
            "세밀함이 덜한(blurred) 영상에 대해 간단한 연산만으로 고주파 성분을 강조하여 영상의 선명도를 개선할 수 있으나, 잡음이 포함된 영상의 경우 잡음도 함께 강조되어 잡음이 심해지는 단점이 있음",
          ],
        },
      ];

      const chapter6 = [
        {
          chapter: "6장",
          question: "영상의 주요한 특징으로 사용되는 에지",
          answer: [
            "사용되는 에지는 미분 연산을 통해 획득될 수 있음",
            "미분 연산은 각 에지 검출기의 특성에 맞는 커널과의 컨벌루션 연산을 통해 수행됨"
          ],
        },
        {
          chapter: "6장",
          question: "에지 검출기",
          answer: [
            "크게 1차 미분 연산자와 2차 미분 연산자로 나눠볼 수 있음",
            "1차 미분 연산자로는 로버트 크로스, 소벨, 프르윗 등이 있음",
            "2차 미분 연산자로는 라플라시안 등이 있음"
          ],
        },
        {
          chapter: "6장",
          question: "로버트 크로스 에지 검출기",
          answer: [
            "45도 방향의 에지에 잘 반응하며, 커널의 크기가 작아서 계산이 빠르나 영상의 잡음에 굉장이 민감한 단점이 있음",
          ],
        },
        {
          chapter: "6장",
          question: "소벨 에지 검출기",
          answer: [
            "수평과 수직 방향의 에지에 잘 반응하며, 로버트 크로스보다는 커널의 크기가 크기 때문에 계산이 좀 더 느리며 더 굵은 에지를 검출함. 역시 잡음에 민감한 단점이 있음",
          ],
        },
        {
          chapter: "6장",
          question: "프르윗 에지 검출기",
          answer: [
            "소벨 커널과 가운데 계수값만 다른 유사한 커널을 사용하기 때문에 소벨과 비슷한 결과를 냄",
          ],
        },
        {
          chapter: "6장",
          question: "캐니 에지 검출기",
          answer: [
            "1차 미분 연산자가 잡음에 민감한 단점을 극복하기 위한 방법",
            "먼저 가우시안 스무딩을 통해 잡음을 제거하고 미분 연산자를 적용하여 에지를 검출한 후에 에지 트래킹을 통해 확실한 에지만을 추출해냄",
            "조정해야 할 파라미터는 3개 (가우시안 필터링 시 스무딩 정도를 결정하는 σ, 에지 트래킹 시 사용되는 높은 임계값, 낮은 임계값)"
          ],
        },
        {
          chapter: "6장",
          question: "라플라시안 에지 검출기",
          answer: [
            "1차 미분 연산자들이 너무 두꺼운 에지를 검출하는데 반해, 지역적으로 최대인 점만 검출함으로써 에지가 가늘게 검출됨",
            "2차 미분 연산으로 인해 잡음에 굉장히 민감한 단점이 존재함",
          ],
        },
        {
          chapter: "6장",
          question: "라플라시안 커널을 이용한 영교차 기법",
          answer: [
            "잡음에 매우 민감함으로 이러한 잡음 문제점을 해결하기 위해서 가우시안-라플라시안 연산자가 개발됨",
            "가우시안-라플라시안 검출기는 라플라시안을 적용하기 전에 가우시안 필터링을 적용시키는 방법으로 잡음을 사전에 제거함으로써, 잡음에 의한 과다한 에지를 줄일 수 있음",
          ],
        },
      ];

      const chapter7 = [
        {
          chapter: "7장",
          question: "영상의 기하학적 변환",
          answer: [
            "픽셀 좌표들의 위치를 변경하여 영상의 구조를 재배치하는 방법으로써, 영상의 전처리에 많이 사용되며, 영상의 해석을 쉽게 할 수 있음",
          ],
        },
        {
          chapter: "7장",
          question: "기하학적 변환",
          answer: [
            "크기 변환, 회전, 반사, 이동 등의 여러 가지 변환들이 있으며, 이들의 선형 결합인 어파인 변환이 있음",
          ],
        },
        {
          chapter: "7장",
          question: "기하학적 변환 시",
          answer: [
            "입력 영상의 좌표에 대응되는 결과 영상의 좌표를 구하는 전방향 매핑이 있으나, 이는 홀 문제와 오버랩 문제를 가짐",
          ],
        },
        {
          chapter: "7장",
          question: "전방향 매핑의 문제점을 보완하기 위해",
          answer: [
            "결과 영상의 좌표에 대응되는 입력 영상의 좌표를 역으로 구하여 변환을 하는 역방향 매핑이 있음",
          ],
        },
        {
          chapter: "7장",
          question: "역방향 매핑 시",
          answer: [
            "좌표값이 소수로 계산되어 어느 좌표로 매핑 시켜야 하는지 모르는 경우가 발생하는데, 이를 위해 새로운 픽셀값을 생성해주는 보간법을 이용함",
          ],
        },
        {
          chapter: "7장",
          question: "보간법",
          answer: [
            "최근접 이웃 픽셀 보간법과 양선형 보간법이 있음",
            "최근접 이웃 픽셀 보간법은 대응되지 않은 픽셀에 대해 그 픽셀과 가장 가까운 입력 영상의 픽셀값으로 복사해서 할당",
            "양선형 보간법은 가장 가까운 4개의 이웃 픽셀값들의 가중치 합을 통해 픽셀값을 생성",
          ],
        },
        {
          chapter: "7장",
          question: "크기 변환",
          answer: [
            "영상의 크기를 변경시키는 변환으로써 축소와 확대 변환이 있으며, 원 좌표값에 변화할 크기만큼 곱함으로써 결과 영상의 좌표를 계산",
          ],
        },
        {
          chapter: "7장",
          question: "회전 변환",
          answer: [
            "중심 좌표와 일정 각도를 가지고 영상을 회전시키는 변환으로써, 사인함수와 코사인 함수를 이용하여 좌표를 변환함",
          ],
        },
        {
          chapter: "7장",
          question: "반사 변환",
          answer: [
            "특정 축이나 점에 대해 반사를 시키지는 변환으로써, 영상의 대칭성을 확인하는데 응용될 수 있음",
          ],
        },
        {
          chapter: "7장",
          question: "이동 변환",
          answer: [
            "영상의 요소를 이동시키는 변환으로써, 원 좌표값에 이동량을 더하거나 빼줌으로써 결과 영상의 좌표를 계산할 수 있음",
          ],
        },
        {
          chapter: "7장",
          question: "어파인 변환",
          answer: [
            "여러 기하학적 변환들의 선형 결합을 통해 영상을 변환시키는 방법",
            "크기, 회전, 반사, 이동과 같은 변환들의 선형 결합 연산을 통해 새로운 좌표값을 계산",
          ],
        },
      ];

      const questions = [
        // ...chapter1,
        // ...chapter2,
        // ...chapter3,
        // ...chapter4,
        ...chapter5,
        ...chapter6,
        ...chapter7,
      ];
      const allChapters = Array.from(
        new Set(questions.map((item) => item.chapter))
      );

      let selectedFilter = [...allChapters];

      const selectRandomQuestion = () => {
        const filteredQuestions = questions.filter((q) =>
          selectedFilter.includes(q.chapter)
        );
        const { question, chapter, answer } =
          filteredQuestions[
            Math.floor(Math.random() * filteredQuestions.length)
          ];

        document.querySelector(
          ".box > .question"
        ).innerHTML = `<strong>[문제]</strong> ${question}`;
        document.querySelector(".answers").style.display = "none";
        document.querySelector(".show-answer").style.display = "inline-block";
        document.querySelector(".box > textarea").value = "";
        document.querySelector(".box > .answers").innerText = "";

        [chapter, ...answer].forEach((item) => {
          const el = document.createElement("li");
          el.innerText = item;
          document
            .querySelector(".box > .answers")
            .insertAdjacentElement("beforeend", el);
        });
      };

      const createFilter = () => {
        const container = document.createElement("div");
        container.classList.add("filter");

        allChapters.forEach((i) => {
          const el = document.createElement("div");
          el.classList.add("filter-item", "selected");
          el.innerText = i;

          el.addEventListener("click", () => {
            if (selectedFilter.includes(i)) {
              el.classList.remove("selected");
              selectedFilter = selectedFilter.filter((s) => s !== i);
            } else {
              el.classList.add("selected");
              selectedFilter.push(i);
            }
          });

          container.insertAdjacentElement("beforeend", el);
        });

        document
          .querySelector(".box")
          .insertAdjacentElement("beforebegin", container);
      };

      const createSelectQuestionButton = () => {
        const el = document.createElement("button");
        el.classList.add("create-question");
        el.innerText = "문제 생성";

        el.addEventListener("click", selectRandomQuestion);

        document.querySelector(".box").insertAdjacentElement("beforebegin", el);
      };

      const createShowAnswerButton = () => {
        const el = document.createElement("button");
        el.classList.add("show-answer");
        el.innerText = "정답 보기";
        el.style.display = "none";

        el.addEventListener("click", () => {
          document.querySelector(".answers").style.display = "flex";
        });

        document.querySelector(".box").insertAdjacentElement("beforebegin", el);
      };

      const createApp = () => {
        createShowAnswerButton();
        createSelectQuestionButton();
        createFilter();
      };

      window.addEventListener("load", () => {
        createApp();
      });
    </script>
  </body>
</html>
